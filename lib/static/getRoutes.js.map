{"version":3,"sources":["../../src/static/getRoutes.js"],"names":["watcher","REGEX_TO_CUT_TO_ROOT","REGEX_TO_REMOVE_TRAILING_SLASH","REGEX_TO_REMOVE_LEADING_SLASH","cutPathToRoot","string","replace","trimLeadingAndTrailingSlashes","consoleWarningForRouteWithoutNoIndex","route","noIndex","console","warn","path","normalizeRoute","parent","config","children","routeWithOutChildren","parentPath","tree","keepRouteChildren","Error","JSON","stringify","originalRoutePath","routePath","normalizedRoute","originalPath","noindex","hasGetProps","getData","recurseNormalizeRoute","routes","existingRoutes","createNestedTreeStructure","reduce","prevRoutes","hasIndex","has404","existingRoute","isPage","Object","assign","component","disableDuplicateRoutesWarning","normalizedRouteChildren","childrenHasIndex","childrenHas404","getRoutesFromPages","cb","opts","globExtensions","extensions","map","ext","slice","join","pagesGlob","paths","PAGES","handle","pages","nodePath","relative","ROOT","page","hasWatcher","dev","chokidar","watch","ignoreInitial","on","type","file","filename","split","reverse","startsWith","getRoutes","d","pageRoutes","allRoutes"],"mappings":"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","file":"getRoutes.js","sourcesContent":["/* eslint-disable import/no-dynamic-require */\n\nimport nodePath from 'path'\nimport chokidar from 'chokidar'\n\nimport { glob, debounce } from '../utils'\nimport { pathJoin } from '../utils/shared'\n\nlet watcher\nconst REGEX_TO_CUT_TO_ROOT = /(\\..+?)\\/.*/g\nconst REGEX_TO_REMOVE_TRAILING_SLASH = /^\\/{0,}/g\nconst REGEX_TO_REMOVE_LEADING_SLASH = /\\/{0,}$/g\n\nexport const cutPathToRoot = (string = '') => string.replace(REGEX_TO_CUT_TO_ROOT, '$1')\n\nexport const trimLeadingAndTrailingSlashes = (string = '') =>\n  string.replace(REGEX_TO_REMOVE_TRAILING_SLASH, '').replace(REGEX_TO_REMOVE_LEADING_SLASH, '')\n\nconst consoleWarningForRouteWithoutNoIndex = route =>\n  route.noIndex &&\n  console.warn(`=> Warning: Route ${route.path} is using 'noIndex'. Did you mean 'noindex'?`)\n\nexport const normalizeRoute = (route, parent = {}, config = {}) => {\n  const { children, ...routeWithOutChildren } = route\n  const { path: parentPath = '/' } = parent\n  const { tree: keepRouteChildren = false } = config\n\n  if (!route.path) {\n    throw new Error(`No path defined for route: ${JSON.stringify(route)}`)\n  }\n\n  const originalRoutePath = pathJoin(route.path)\n  const routePath = pathJoin(parentPath, route.path)\n\n  consoleWarningForRouteWithoutNoIndex(route)\n\n  const normalizedRoute = {\n    ...(keepRouteChildren ? route : routeWithOutChildren),\n    path: routePath,\n    originalPath: originalRoutePath,\n    noindex: route.noindex || parent.noindex || route.noIndex,\n    hasGetProps: !!route.getData,\n  }\n\n  return normalizedRoute\n}\n\n// We recursively loop through the routes and their children and\n// return an array of normalised routes.\n// Original routes array [{ path: 'path', children: { path: 'to' } }]\n// These can be returned as flat routes eg. [{ path: 'path' }, { path: 'path/to' }]\n// Or they can be returned nested routes eg. [{ path: 'path', children: { path: 'path/to' } }]\nexport const recurseNormalizeRoute = (routes = [], config, parent, existingRoutes = {}) => {\n  const { tree: createNestedTreeStructure = false } = config\n\n  return routes.reduce(\n    ({ routes: prevRoutes = [], hasIndex, has404 }, route) => {\n      let normalizedRoute = normalizeRoute(route, parent, config)\n      // if structure is nested (tree === true) normalizedRoute will\n      // have children otherwise we fall back to the original route children\n      const { children = route.children, path } = normalizedRoute\n\n      // we check an array of paths to see\n      // if route path already existings\n      const existingRoute = existingRoutes[path]\n\n      if (existingRoute) {\n        if (existingRoute.isPage) {\n          Object.assign(existingRoute, {\n            ...normalizedRoute,\n            component: existingRoute.component,\n          })\n        } else if (!config.disableDuplicateRoutesWarning) {\n          console.warn('More than one route in static.config.js is defined for path:', route.path)\n        }\n      }\n\n      const {\n        routes: normalizedRouteChildren,\n        hasIndex: childrenHasIndex,\n        has404: childrenHas404,\n      } = recurseNormalizeRoute(children, config, normalizedRoute, existingRoutes)\n\n      if (createNestedTreeStructure) {\n        normalizedRoute = { ...normalizedRoute, children: normalizedRouteChildren }\n      }\n\n      // we push paths into an array that\n      // we use to check if a route existings\n      existingRoutes[path] = normalizedRoute\n\n      return {\n        routes: [\n          ...prevRoutes,\n          // if route exists we don't include the route\n          ...(existingRoute ? [] : [normalizedRoute]),\n          // if structure is not nested (tree === false) we return an empty object\n          // else we return an array of normalized children routes\n          ...(createNestedTreeStructure ? [] : normalizedRouteChildren),\n        ],\n        hasIndex: hasIndex || normalizedRoute.path === '/' || childrenHasIndex,\n        has404: has404 || normalizedRoute.path === '404' || childrenHas404,\n      }\n    },\n    {\n      routes: [],\n      hasIndex: false,\n      has404: false,\n    }\n  )\n}\n\nexport const getRoutesFromPages = async ({ config, opts = {} }, cb) => {\n  // Make a glob extension to get all pages with the set extensions from the pages directory\n  const globExtensions = config.extensions.map(ext => `${ext.slice(1)}`).join(',')\n  const pagesGlob = `${config.paths.PAGES}/**/*.{${globExtensions}}`\n  // Get the pages\n\n  const handle = pages => {\n    // Turn each page into a route\n    const routes = pages.map(page => {\n      // Get the component path relative to ROOT\n      const component = nodePath.relative(config.paths.ROOT, page)\n      // Make sure the path is relative to the root of the site\n      let path = page.replace(`${config.paths.PAGES}`, '').replace(/\\..*/, '')\n      // Turn `/index` paths into roots`\n      path = path.replace(/\\/index$/, '/')\n      // Return the route\n      return {\n        path,\n        component,\n        isPage: true, // tag it with isPage, so we know its origin\n      }\n    })\n    return routes\n  }\n\n  const hasWatcher = !!watcher\n  if (opts.dev && !hasWatcher) {\n    watcher = chokidar\n      .watch(config.paths.PAGES, {\n        ignoreInitial: true,\n      })\n      .on(\n        'all',\n        debounce(async (type, file) => {\n          const filename = file.split('/').reverse()[0]\n          if (filename.startsWith('.')) {\n            return\n          }\n          const pages = await glob(pagesGlob)\n          const routes = handle(pages)\n          cb(routes)\n        }),\n        50\n      )\n  }\n  if (!hasWatcher) {\n    const pages = await glob(pagesGlob)\n    const routes = handle(pages)\n    return cb(routes)\n  }\n}\n\n// At least ensure the index page is defined for export\nconst getRoutes = async ({ config, opts }, cb = d => d) =>\n  // We use the callback pattern here, because getRoutesFromPages is technically a subscription\n  getRoutesFromPages({ config, opts }, async pageRoutes => {\n    const routes = await config.getRoutes(opts)\n    const { routes: allRoutes, hasIndex, has404 } = recurseNormalizeRoute(\n      [...pageRoutes, ...routes],\n      config\n    )\n    // If no Index page was found, throw an error. This is required\n    if (!hasIndex) {\n      throw new Error(\n        'Could not find a route for the \"index\" page of your site! This is required. Please create a page or specify a route and template for this page.'\n      )\n    }\n    // If no 404 page was found, throw an error. This is required\n    if (!has404) {\n      throw new Error(\n        'Could not find a route for the \"404\" page of your site! This is required. Please create a page or specify a route and template for this page.'\n      )\n    }\n    return cb(allRoutes)\n  })\n\nexport default getRoutes\n"]}