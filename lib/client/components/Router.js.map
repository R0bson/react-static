{"version":3,"sources":["../../../src/client/components/Router.js"],"names":["Router","props","context","routeInfo","path","staticURL","document","window","__routeInfo","href","location","templateID","bootstrapRouteInfo","history","type","children","autoScrollToTop","autoScrollToHash","scrollToTopDuration","scrollToHashDuration","scrollToHashOffset","showErrorsInProduction","rest","undefined","disableRoutePrefixing","process","env","REACT_STATIC_DISABLE_ROUTE_PREFIXING","ready","state","ResolvedRouter","resolvedHistory","StaticRouter","ReactRouter","global","__reactStaticRouterHistory","options","basename","REACT_STATIC_BASEPATH","patchHistoryNavigation","REACT_STATIC_ENV","React","Component","defaultProps","contextTypes","PropTypes","string","object","decodeURIComponent","allProps","Object","keys","sharedPropsHashes","forEach","propsByHash","propKey","priority","setState","patchedNavigation","originalMethod","method","args","shouldPrefetch","apply"],"mappings":"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","file":"Router.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport createBrowserHistory from 'history/createBrowserHistory'\nimport createMemoryHistory from 'history/createMemoryHistory'\nimport createHashHistory from 'history/createHashHistory'\nimport { Router as ReactRouter, StaticRouter } from 'react-router-dom'\n//\nimport { cleanPath } from '../../utils/shared'\nimport {\n  getRouteInfo,\n  propsByHash,\n  needsPrefetch,\n  prefetch,\n  setLoading,\n  registerTemplateIDForPath,\n} from '../methods'\nimport RouterScroller from './RouterScroller'\nimport DevSpinner from './DevSpinner'\nimport ErrorWrapper from './ErrorWrapper'\n\nexport default class Router extends React.Component {\n  static defaultProps = {\n    type: 'browser',\n    autoScrollToTop: true,\n    autoScrollToHash: true,\n    scrollToTopDuration: 0,\n    scrollToHashDuration: 800,\n    scrollToHashOffset: 0,\n    showErrorsInProduction: false,\n  }\n  static contextTypes = {\n    staticURL: PropTypes.string,\n    routeInfo: PropTypes.object,\n  }\n  state = {\n    ready: false,\n  }\n  constructor (props, context) {\n    super()\n\n    // In SRR and production, synchronously register the templateID for the\n    // initial path\n    let { routeInfo } = context\n    let path = cleanPath(context.staticURL)\n\n    if (typeof document !== 'undefined') {\n      routeInfo = window.__routeInfo\n      const { href } = window.location\n      path = cleanPath(href)\n    }\n\n    if (routeInfo) {\n      registerTemplateIDForPath(path, routeInfo.templateID)\n    }\n  }\n  componentDidMount () {\n    this.bootstrapRouteInfo()\n  }\n  bootstrapRouteInfo = () =>\n    (async () => {\n      if (typeof window !== 'undefined') {\n        // Get the entry path from location\n        const href = decodeURIComponent(window.location.href)\n        const path = cleanPath(href)\n\n        // Injest and cache the embedded routeInfo in the page if possible\n        if (window.__routeInfo && window.__routeInfo.path === path) {\n          const { allProps } = window.__routeInfo\n          Object.keys(window.__routeInfo.sharedPropsHashes).forEach(propKey => {\n            propsByHash[window.__routeInfo.sharedPropsHashes[propKey]] = allProps[propKey]\n          })\n        }\n\n        // In dev mode, request the templateID and ready the router\n        if (process.env.REACT_STATIC_ENV === 'development') {\n          try {\n            const routeInfo = await getRouteInfo(path, { priority: true })\n            if (routeInfo) {\n              registerTemplateIDForPath(path, routeInfo.templateID)\n            }\n          } finally {\n            this.setState({ ready: true })\n          }\n        }\n      }\n    })()\n  patchHistoryNavigation = resolvedHistory => {\n    // Only patch navigation once\n    if (this.patchedNavigation) {\n      return\n    }\n    // Here, we patch the push and replace methods on history so we can\n    // intercept them.\n    ['push', 'replace'].forEach(method => {\n      // Hold on to the original method, we will need it.\n      const originalMethod = resolvedHistory[method]\n      // Replace it with our own patched version\n      resolvedHistory[method] = async (...args) => {\n        // Clean the path first\n        const path = cleanPath(typeof args[0] === 'string' ? args[0] : args[0].path)\n        // Notify a soft loading state\n        setLoading(1)\n        // Determine as quickly as possible if we need to fetch data for this route\n        const shouldPrefetch = await needsPrefetch(path, { priority: true })\n\n        // If we need to load...\n        if (shouldPrefetch) {\n          // Notify with a hard loading state\n          setLoading(2)\n          // Prefetch any data or templates needed with a high priority\n          await prefetch(path, {\n            priority: true,\n          })\n        }\n\n        // Notify we're done loading\n        setLoading(0)\n\n        // Apply the original method and arguments as if nothing happened\n        originalMethod.apply(resolvedHistory, args)\n      }\n    })\n\n    // Only patch navigation once :)\n    this.patchedNavigation = true\n  }\n  render () {\n    const {\n      history,\n      type,\n      children,\n      autoScrollToTop,\n      autoScrollToHash,\n      scrollToTopDuration,\n      scrollToHashDuration,\n      scrollToHashOffset,\n      showErrorsInProduction,\n      ...rest\n    } = this.props\n    const { staticURL } = this.context\n    const context = staticURL ? {} : undefined\n    const disableRoutePrefixing = process.env.REACT_STATIC_DISABLE_ROUTE_PREFIXING === 'true'\n\n    const { ready } = this.state\n\n    let ResolvedRouter\n    let resolvedHistory\n\n    // If statically rendering, use the static router\n    if (staticURL) {\n      ResolvedRouter = StaticRouter\n      resolvedHistory = undefined\n    } else {\n      ResolvedRouter = ReactRouter\n      resolvedHistory = history || global.__reactStaticRouterHistory\n      if (!resolvedHistory) {\n        if (type === 'memory') {\n          resolvedHistory = createMemoryHistory()\n        } else if (type === 'hash') {\n          resolvedHistory = createHashHistory()\n        } else {\n          const options = disableRoutePrefixing\n            ? {}\n            : { basename: process.env.REACT_STATIC_BASEPATH }\n          resolvedHistory = createBrowserHistory(options)\n        }\n      }\n      global.__reactStaticRouterHistory = resolvedHistory\n      this.patchHistoryNavigation(resolvedHistory)\n    }\n\n    if (process.env.REACT_STATIC_ENV === 'development' && !ready) {\n      return <DevSpinner />\n    }\n\n    return (\n      <ErrorWrapper showErrorsInProduction={showErrorsInProduction}>\n        <ResolvedRouter\n          history={resolvedHistory}\n          location={staticURL}\n          context={context}\n          basename={\n            disableRoutePrefixing\n              ? ''\n              : process.env.REACT_STATIC_BASEPATH\n          }\n          {...rest}\n        >\n          <RouterScroller\n            {...{\n              autoScrollToTop,\n              autoScrollToHash,\n              scrollToTopDuration,\n              scrollToHashDuration,\n              scrollToHashOffset,\n            }}\n          >\n            {children}\n          </RouterScroller>\n        </ResolvedRouter>\n      </ErrorWrapper>\n    )\n  }\n}\n"]}